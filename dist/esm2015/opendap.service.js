import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { parseData, parseDAS, parseDDX, simplify } from 'dap-query-js/dist/dap-query';
import { map, switchMap } from 'rxjs/operators';
import { forkJoin } from 'rxjs';
let OpendapService = class OpendapService {
    constructor(http) {
        this.http = http;
    }
    makeURL(host, filepath) {
        return host.url + '/dodsC/' + filepath;
    }
    get(url) {
        return this.http.get(url, { responseType: 'text' });
    }
    getData(queryUrl, das) {
        return this.get(queryUrl).pipe(map((txt) => simplify(parseData(txt, das))));
    }
    getDAS(url) {
        return this.get(url + '.das').pipe(map(parseDAS));
    }
    getDDX(url) {
        return this.get(url + '.ddx').pipe(map(parseDDX));
    }
    getExtent(url) {
        console.log(url);
        return forkJoin([
            this.getDAS(url),
            this.getDDX(url)
        ]).pipe(switchMap(([theDAS, theDDX]) => {
            var das = theDAS;
            return forkJoin([
                this.getData(url + '.ascii?latitude', das),
                this.getData(url + '.ascii?longitude', das)
            ]);
        }), map((ll) => {
            var lats = ll[0].latitude;
            var lons = ll[1].longitude;
            return [lats[0], lats[lats.length - 1],
                lons[0], lons[lons.length - 1]];
        }));
    }
    dapRangeQuery(from, to, step) {
        step = step || 1;
        if (to === undefined) {
            to = from;
        }
        return '[' + from + ':' + step + ':' + to + ']';
    }
};
OpendapService.ctorParameters = () => [
    { type: HttpClient }
];
OpendapService = tslib_1.__decorate([
    Injectable(),
    tslib_1.__metadata("design:paramtypes", [HttpClient])
], OpendapService);
export { OpendapService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BlbmRhcC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbWFwLXdhbGQvIiwic291cmNlcyI6WyJvcGVuZGFwLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFDLFFBQVEsRUFDbkMsUUFBUSxFQUFpRCxNQUFNLDZCQUE2QixDQUFDO0FBRS9GLE9BQU8sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDaEQsT0FBTyxFQUFhLFFBQVEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUczQyxJQUFhLGNBQWMsR0FBM0IsTUFBYSxjQUFjO0lBRXpCLFlBQW9CLElBQWU7UUFBZixTQUFJLEdBQUosSUFBSSxDQUFXO0lBRW5DLENBQUM7SUFFRCxPQUFPLENBQUMsSUFBZ0IsRUFBQyxRQUFlO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLEdBQUcsR0FBRyxTQUFTLEdBQUcsUUFBUSxDQUFDO0lBQ3pDLENBQUM7SUFFRCxHQUFHLENBQUMsR0FBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFDLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUE7SUFDcEQsQ0FBQztJQUVELE9BQU8sQ0FBQyxRQUFlLEVBQUMsR0FBVTtRQUNoQyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUM1QixHQUFHLENBQUMsQ0FBQyxHQUFVLEVBQUMsRUFBRSxDQUFBLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRCxNQUFNLENBQUMsR0FBVTtRQUNmLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUM5QixHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQsTUFBTSxDQUFDLEdBQVU7UUFDZixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FDOUIsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVELFNBQVMsQ0FBQyxHQUFVO1FBQ2xCLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakIsT0FBTyxRQUFRLENBQUM7WUFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztZQUNoQixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztTQUNqQixDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFDLE1BQU0sQ0FBQyxFQUFDLEVBQUU7WUFDbkMsSUFBSSxHQUFHLEdBQWtCLE1BQU0sQ0FBQztZQUNoQyxPQUFPLFFBQVEsQ0FBQztnQkFDZCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBQyxpQkFBaUIsRUFBQyxHQUFHLENBQUM7Z0JBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFDLGtCQUFrQixFQUFDLEdBQUcsQ0FBQzthQUN6QyxDQUFDLENBQUE7UUFBQSxDQUFDLENBQUMsRUFDSixHQUFHLENBQUMsQ0FBQyxFQUFZLEVBQUMsRUFBRTtZQUNsQixJQUFJLElBQUksR0FBeUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztZQUNoRCxJQUFJLElBQUksR0FBeUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUNqRCxPQUFPLENBQVMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQztnQkFDbkMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkQsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNSLENBQUM7SUFFRCxhQUFhLENBQUMsSUFBVyxFQUFDLEVBQVUsRUFBQyxJQUFZO1FBQy9DLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDO1FBQ2pCLElBQUcsRUFBRSxLQUFHLFNBQVMsRUFBQztZQUNoQixFQUFFLEdBQUcsSUFBSSxDQUFDO1NBQ1g7UUFDRCxPQUFPLEdBQUcsR0FBQyxJQUFJLEdBQUMsR0FBRyxHQUFDLElBQUksR0FBQyxHQUFHLEdBQUMsRUFBRSxHQUFDLEdBQUcsQ0FBQztJQUN0QyxDQUFDO0NBQ0YsQ0FBQTs7WUFyRDBCLFVBQVU7O0FBRnhCLGNBQWM7SUFEMUIsVUFBVSxFQUFFOzZDQUdjLFVBQVU7R0FGeEIsY0FBYyxDQXVEMUI7U0F2RFksY0FBYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBwYXJzZURhdGEsIHBhcnNlREFTLHBhcnNlRERYLFxuICBzaW1wbGlmeSwgRGFwRGF0YSwgRGFwREFTLCBEYXBERFgsIERhcFZhcmlhYmxlRGF0YUFycmF5IH0gZnJvbSAnZGFwLXF1ZXJ5LWpzL2Rpc3QvZGFwLXF1ZXJ5JztcbmltcG9ydCB7IENhdGFsb2dIb3N0IH0gZnJvbSAnLi9kYXRhL2NhdGFsb2cnO1xuaW1wb3J0IHsgbWFwLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLGZvcmtKb2luIH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBPcGVuZGFwU2VydmljZSB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOkh0dHBDbGllbnQpIHtcblxuICB9XG5cbiAgbWFrZVVSTChob3N0OkNhdGFsb2dIb3N0LGZpbGVwYXRoOnN0cmluZyk6c3RyaW5ne1xuICAgIHJldHVybiBob3N0LnVybCArICcvZG9kc0MvJyArIGZpbGVwYXRoO1xuICB9XG5cbiAgZ2V0KHVybDpzdHJpbmcpOk9ic2VydmFibGU8c3RyaW5nPntcbiAgICByZXR1cm4gdGhpcy5odHRwLmdldCh1cmwseyByZXNwb25zZVR5cGU6ICd0ZXh0JyB9KVxuICB9XG5cbiAgZ2V0RGF0YShxdWVyeVVybDpzdHJpbmcsZGFzOkRhcERBUyk6T2JzZXJ2YWJsZTxEYXBEYXRhPntcbiAgICByZXR1cm4gdGhpcy5nZXQocXVlcnlVcmwpLnBpcGUoXG4gICAgICBtYXAoKHR4dDpzdHJpbmcpPT5zaW1wbGlmeShwYXJzZURhdGEodHh0LGRhcykpKSk7XG4gIH1cblxuICBnZXREQVModXJsOnN0cmluZyk6T2JzZXJ2YWJsZTxEYXBEQVM+e1xuICAgIHJldHVybiB0aGlzLmdldCh1cmwrJy5kYXMnKS5waXBlKFxuICAgICAgbWFwKHBhcnNlREFTKSk7XG4gIH1cblxuICBnZXRERFgodXJsOnN0cmluZyk6T2JzZXJ2YWJsZTxEYXBERFg+e1xuICAgIHJldHVybiB0aGlzLmdldCh1cmwrJy5kZHgnKS5waXBlKFxuICAgICAgbWFwKHBhcnNlRERYKSk7XG4gIH1cblxuICBnZXRFeHRlbnQodXJsOnN0cmluZyk6T2JzZXJ2YWJsZTxudW1iZXJbXT57XG4gICAgY29uc29sZS5sb2codXJsKTtcbiAgICByZXR1cm4gZm9ya0pvaW4oW1xuICAgICAgdGhpcy5nZXREQVModXJsKSxcbiAgICAgIHRoaXMuZ2V0RERYKHVybClcbiAgICBdKS5waXBlKHN3aXRjaE1hcCgoW3RoZURBUyx0aGVERFhdKT0+e1xuICAgICAgdmFyIGRhczpEYXBEQVMgPSA8RGFwREFTPnRoZURBUztcbiAgICAgIHJldHVybiBmb3JrSm9pbihbXG4gICAgICAgIHRoaXMuZ2V0RGF0YSh1cmwrJy5hc2NpaT9sYXRpdHVkZScsZGFzKSxcbiAgICAgICAgdGhpcy5nZXREYXRhKHVybCsnLmFzY2lpP2xvbmdpdHVkZScsZGFzKVxuICAgICAgXSl9KSxcbiAgICAgIG1hcCgobGw6RGFwRGF0YVtdKT0+e1xuICAgICAgICB2YXIgbGF0cyA9IDxEYXBWYXJpYWJsZURhdGFBcnJheT5sbFswXS5sYXRpdHVkZTtcbiAgICAgICAgdmFyIGxvbnMgPSA8RGFwVmFyaWFibGVEYXRhQXJyYXk+bGxbMV0ubG9uZ2l0dWRlO1xuICAgICAgICByZXR1cm4gWzxudW1iZXI+bGF0c1swXSw8bnVtYmVyPmxhdHNbbGF0cy5sZW5ndGgtMV0sXG4gICAgICAgICAgICAgICAgPG51bWJlcj5sb25zWzBdLDxudW1iZXI+bG9uc1tsb25zLmxlbmd0aC0xXV07XG4gICAgICB9KSk7XG4gIH1cblxuICBkYXBSYW5nZVF1ZXJ5KGZyb206bnVtYmVyLHRvPzpudW1iZXIsc3RlcD86bnVtYmVyKTpzdHJpbmd7XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcbiAgICBpZih0bz09PXVuZGVmaW5lZCl7XG4gICAgICB0byA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiAnWycrZnJvbSsnOicrc3RlcCsnOicrdG8rJ10nO1xuICB9XG59XG4iXX0=