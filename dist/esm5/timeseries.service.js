import { __read } from "tslib";
import { Injectable } from '@angular/core';
import { OpendapService } from './opendap.service';
import { MetadataService, LAT_NAMES, LNG_NAMES, TIME_NAMES } from './metadata.service';
import { forkJoin } from 'rxjs';
import { switchMap, map } from 'rxjs/operators';
;
var TimeseriesService = /** @class */ (function () {
    function TimeseriesService(metadata, dap) {
        this.metadata = metadata;
        this.dap = dap;
    }
    TimeseriesService.prototype.getTimeseries = function (host, file, variable, pt, additionalIndices, fillValue) {
        var _this = this;
        additionalIndices = additionalIndices || {};
        var url = this.dap.makeURL(host, file);
        var ddx$ = this.metadata.ddxForUrl(url);
        var das$ = this.metadata.dasForUrl(url);
        var variable = variable;
        return forkJoin(ddx$, das$, this.metadata.getGrid(host, file)).pipe(switchMap(function (_a) {
            var _b = __read(_a, 3), ddx = _b[0], das = _b[1], latsAndLngs = _b[2];
            var lats = latsAndLngs[0];
            var lngs = latsAndLngs[1];
            var latIndex = _this.indexInDimension(pt.lat, lats);
            var lngIndex = _this.indexInDimension(pt.lng, lngs);
            if (fillValue === undefined) {
                fillValue = +ddx.variables[variable]._FillValue;
            }
            var query = _this.makeTimeQuery(ddx, variable, latIndex, lngIndex, additionalIndices);
            return _this.dap.getData(url + ".ascii?" + variable + query, das);
        }), map(function (data) {
            var vals = data[variable];
            if (!vals.length) {
                vals = [data[variable]];
            }
            var dates = (data.time || data.t);
            if (dates && !dates.length) {
                dates = [data.time || data.t];
            }
            return {
                dates: dates,
                values: vals.map(function (v) { return (v === fillValue) ? NaN : v; })
            };
        }));
    };
    TimeseriesService.prototype.getTimeseriesForLayer = function (ml, pt) {
        return this.getTimeseries(ml.flattenedSettings.host, ml.interpolatedFile, ml.flattenedSettings.layer || ml.flattenedSettings.variable, pt, null, ml.flattenedSettings.fillValue);
    };
    TimeseriesService.prototype.makeTimeQuery = function (ddx, variable, latIndex, lngIndex, additionalIndices) {
        var _this = this;
        var metadata = ddx.variables[variable];
        var query = '';
        metadata.dimensions.forEach(function (dim) {
            var dName = dim.name.toLowerCase();
            if (TIME_NAMES.indexOf(dName) >= 0) {
                query += _this.dapRangeQuery(0, +(dim.size) - 1);
            }
            else if (LAT_NAMES.indexOf(dName) >= 0) {
                query += _this.dapRangeQuery(latIndex);
            }
            else if (LNG_NAMES.indexOf(dName) >= 0) {
                query += _this.dapRangeQuery(lngIndex);
            }
            else {
                query += _this.dapRangeQuery(additionalIndices[dName] || 0);
            }
        });
        return query;
    };
    TimeseriesService.prototype.dapRangeQuery = function (from, to, step) {
        step = step || 1;
        if (to === undefined) {
            to = from;
        }
        return '[' + from + ':' + step + ':' + to + ']';
    };
    TimeseriesService.prototype.indexInDimension = function (c, dim, trim) {
        var minIndex = 0;
        var maxIndex = dim.length - 1;
        if (trim) {
            maxIndex -= trim;
        }
        var rev = dim[0] > dim[dim.length - 1];
        if (rev) {
            minIndex = maxIndex;
            maxIndex = 0;
        }
        var currentIndex;
        while ((minIndex <= maxIndex) || (rev && (maxIndex <= minIndex))) {
            if (c <= dim[minIndex]) {
                return minIndex;
            }
            if (c >= dim[maxIndex]) {
                return maxIndex;
            }
            currentIndex = Math.floor((minIndex + maxIndex) / 2);
            var d1 = Math.abs(dim[currentIndex] - c);
            var d2 = Math.abs(dim[currentIndex + 1] - c);
            if (rev) {
                if (d2 <= d1) {
                    maxIndex = currentIndex + 1;
                }
                else {
                    minIndex = currentIndex;
                }
            }
            else {
                if (d2 <= d1) {
                    minIndex = currentIndex + 1;
                }
                else {
                    maxIndex = currentIndex;
                }
            }
        }
        return currentIndex;
    };
    ;
    TimeseriesService.ctorParameters = function () { return [
        { type: MetadataService },
        { type: OpendapService }
    ]; };
    TimeseriesService.decorators = [
        { type: Injectable }
    ];
    TimeseriesService.ctorParameters = function () { return [
        { type: MetadataService },
        { type: OpendapService }
    ]; };
    return TimeseriesService;
}());
export { TimeseriesService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXNlcmllcy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbWFwLXdhbGQvIiwic291cmNlcyI6WyJ0aW1lc2VyaWVzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxlQUFlLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUd2RixPQUFPLEVBQUUsUUFBUSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUF5Qi9DLENBQUM7QUFFRjtJQUdFLDJCQUFvQixRQUF3QixFQUFTLEdBQWtCO1FBQW5ELGFBQVEsR0FBUixRQUFRLENBQWdCO1FBQVMsUUFBRyxHQUFILEdBQUcsQ0FBZTtJQUV2RSxDQUFDO0lBRUQseUNBQWEsR0FBYixVQUFjLElBQWdCLEVBQUMsSUFBVyxFQUFDLFFBQWUsRUFDNUMsRUFBd0IsRUFBQyxpQkFBcUIsRUFDOUMsU0FBaUI7UUFGL0IsaUJBaUNDO1FBOUJDLGlCQUFpQixHQUFHLGlCQUFpQixJQUFJLEVBQUUsQ0FBQztRQUM1QyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEMsSUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3hCLE9BQU8sUUFBUSxDQUFDLElBQUksRUFBQyxJ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QUksRUFBRSxFQUFFO29CQUNWLFFBQVEsR0FBRyxZQUFZLEdBQUcsQ0FBQyxDQUFDO2lCQUMvQjtxQkFBTTtvQkFDSCxRQUFRLEdBQUcsWUFBWSxDQUFDO2lCQUMzQjthQUNGO1NBQ0Y7UUFDRCxPQUFPLFlBQVksQ0FBQztJQUN0QixDQUFDO0lBQUEsQ0FBQzs7Z0JBeEgyQixlQUFlO2dCQUFhLGNBQWM7OztnQkFIeEUsVUFBVTs7O2dCQS9CRixlQUFlO2dCQURmLGNBQWM7O0lBNkp2Qix3QkFBQztDQUFBLEFBN0hELElBNkhDO1NBNUhZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hcHBlZExheWVyIH0gZnJvbSAnLi9kYXRhL21hcHBlZC1sYXllcic7XG5pbXBvcnQgeyBPcGVuZGFwU2VydmljZSB9IGZyb20gJy4vb3BlbmRhcC5zZXJ2aWNlJztcbmltcG9ydCB7IE1ldGFkYXRhU2VydmljZSwgTEFUX05BTUVTLCBMTkdfTkFNRVMsIFRJTUVfTkFNRVMgfSBmcm9tICcuL21ldGFkYXRhLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGFwRERYLCBEYXBEQVMsIERhcERhdGEgfSBmcm9tICdkYXAtcXVlcnktanMvZGlzdC9kYXAtcXVlcnknO1xuaW1wb3J0IHsgQ2F0YWxvZ0hvc3QgfSBmcm9tICcuL2RhdGEvY2F0YWxvZyc7XG5pbXBvcnQgeyBmb3JrSm9pbiwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF0TG5nIHtcbiAgLy8gZ29vZ2xlIG1hcHNcbiAgbGF0KCk6IG51bWJlcjtcbiAgbG5nKCk6IG51bWJlcjtcbiAgdG9KU09OKCk6IGFueTtcbiAgdG9TdHJpbmcoKTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVTZXJpZXN7XG4gIGRhdGVzOkFycmF5PERhdGU+O1xuICB2YWx1ZXM6QXJyYXk8bnVtYmVyPjtcbiAgbGFiZWw/OnN0cmluZztcbiAgdGFncz86e1xuICAgIFtrZXk6c3RyaW5nXTphbnlcbiAgfTtcbiAgc3R5bGU/OnN0cmluZztcbiAgdW5pdHM/OnN0cmluZztcbiAgW2tleTpzdHJpbmddOmFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVMYXRMbmd7XG4gIGxhdDpudW1iZXIsXG4gIGxuZzpudW1iZXJcbn07XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUaW1lc2VyaWVzU2VydmljZSB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBtZXRhZGF0YTpNZXRhZGF0YVNlcnZpY2UscHJpdmF0ZSBkYXA6T3BlbmRhcFNlcnZpY2UpIHtcblxuICB9XG5cbiAgZ2V0VGltZXNlcmllcyhob3N0OkNhdGFsb2dIb3N0LGZpbGU6c3RyaW5nLHZhcmlhYmxlOnN0cmluZyxcbiAgICAgICAgICAgICAgICBwdDooTGF0TG5nfFNpbXBsZUxhdExuZyksYWRkaXRpb25hbEluZGljZXM6YW55LFxuICAgICAgICAgICAgICAgIGZpbGxWYWx1ZT86bnVtYmVyKTpPYnNlcnZhYmxlPFRpbWVTZXJpZXM+e1xuICAgIGFkZGl0aW9uYWxJbmRpY2VzID0gYWRkaXRpb25hbEluZGljZXMgfHwge307XG4gICAgdmFyIHVybCA9IHRoaXMuZGFwLm1ha2VVUkwoaG9zdCxmaWxlKTtcbiAgICB2YXIgZGR4JCA9IHRoaXMubWV0YWRhdGEuZGR4Rm9yVXJsKHVybCk7XG4gICAgdmFyIGRhcyQgPSB0aGlzLm1ldGFkYXRhLmRhc0ZvclVybCh1cmwpO1xuICAgIHZhciB2YXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgIHJldHVybiBmb3JrSm9pbihkZHgkLGRhcyQsdGhpcy5tZXRhZGF0YS5nZXRHcmlkKGhvc3QsZmlsZSkpLnBpcGUoc3dpdGNoTWFwKFxuICAgICAgKFtkZHgsZGFzLGxhdHNBbmRMbmdzXSk9PntcbiAgICAgICAgY29uc3QgbGF0czpudW1iZXJbXSA9ICg8bnVtYmVyW11bXT5sYXRzQW5kTG5ncylbMF07XG4gICAgICAgIGNvbnN0IGxuZ3M6bnVtYmVyW10gPSAoPG51bWJlcltdW10+bGF0c0FuZExuZ3MpWzFdO1xuICAgICAgdmFyIGxhdEluZGV4ID0gdGhpcy5pbmRleEluRGltZW5zaW9uKCg8YW55PnB0KS5sYXQsbGF0cyk7XG4gICAgICB2YXIgbG5nSW5kZXggPSB0aGlzLmluZGV4SW5EaW1lbnNpb24oKDxhbnk+cHQpLmxuZyxsbmdzKTtcbiAgICAgIGlmKGZpbGxWYWx1ZT09PXVuZGVmaW5lZCl7XG4gICAgICAgIGZpbGxWYWx1ZSA9ICsoPERhcEREWD5kZHgpLnZhcmlhYmxlc1t2YXJpYWJsZV0uX0ZpbGxWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBxdWVyeSA9IHRoaXMubWFrZVRpbWVRdWVyeSg8RGFwRERYPmRkeCx2YXJpYWJsZSxsYXRJbmRleCxsbmdJbmRleCxhZGRpdGlvbmFsSW5kaWNlcyk7XG4gICAgICByZXR1cm4gdGhpcy5kYXAuZ2V0RGF0YShgJHt1cmx9LmFzY2lpPyR7dmFyaWFibGV9JHtxdWVyeX1gLDxEYXBEQVM+ZGFzKVxuICAgIH0pLG1hcCgoZGF0YTpEYXBEYXRhKT0+e1xuICAgICAgbGV0IHZhbHMgPSAoPG51bWJlcltdPiBkYXRhW3ZhcmlhYmxlXSk7XG4gICAgICBpZighdmFscy5sZW5ndGgpe1xuICAgICAgICB2YWxzID0gWzxudW1iZXI+ZGF0YVt2YXJpYWJsZV1dO1xuICAgICAgfVxuICAgICAgbGV0IGRhdGVzID0gPERhdGVbXT4oZGF0YS50aW1lfHxkYXRhLnQpO1xuICAgICAgaWYoZGF0ZXMmJiFkYXRlcy5sZW5ndGgpe1xuICAgICAgICBkYXRlcyA9IDxEYXRlW10+W2RhdGEudGltZXx8ZGF0YS50XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGVzOmRhdGVzLFxuICAgICAgICB2YWx1ZXM6dmFscy5tYXAodj0+KHY9PT1maWxsVmFsdWUpP05hTjp2KVxuICAgICAgfTtcbiAgICB9KSk7XG4gIH1cblxuICBnZXRUaW1lc2VyaWVzRm9yTGF5ZXIobWw6TWFwcGVkTGF5ZXIscHQ6TGF0TG5nKTpPYnNlcnZhYmxlPFRpbWVTZXJpZXM+e1xuICAgIHJldHVybiB0aGlzLmdldFRpbWVzZXJpZXMobWwuZmxhdHRlbmVkU2V0dGluZ3MuaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1sLmludGVycG9sYXRlZEZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbC5mbGF0dGVuZWRTZXR0aW5ncy5sYXllcnx8bWwuZmxhdHRlbmVkU2V0dGluZ3MudmFyaWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbC5mbGF0dGVuZWRTZXR0aW5ncy5maWxsVmFsdWUpO1xuICB9XG5cblxuICBtYWtlVGltZVF1ZXJ5KGRkeDpEYXBERFgsdmFyaWFibGU6c3RyaW5nLGxhdEluZGV4Om51bWJlcixsbmdJbmRleDpudW1iZXIsYWRkaXRpb25hbEluZGljZXM6YW55KTpzdHJpbmd7XG4gICAgdmFyIG1ldGFkYXRhID0gZGR4LnZhcmlhYmxlc1t2YXJpYWJsZV07XG4gICAgdmFyIHF1ZXJ5PScnO1xuXG4gICAgbWV0YWRhdGEuZGltZW5zaW9ucy5mb3JFYWNoKChkaW06YW55KT0+e1xuICAgICAgdmFyIGROYW1lOnN0cmluZyA9IGRpbS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZihUSU1FX05BTUVTLmluZGV4T2YoZE5hbWUpPj0wKXtcbiAgICAgICAgcXVlcnkgKz0gdGhpcy5kYXBSYW5nZVF1ZXJ5KDAsKyhkaW0uc2l6ZSktMSk7XG4gICAgICB9IGVsc2UgaWYoTEFUX05BTUVTLmluZGV4T2YoZE5hbWUpPj0wKXtcbiAgICAgICAgICBxdWVyeSArPSB0aGlzLmRhcFJhbmdlUXVlcnkobGF0SW5kZXgpO1xuICAgICAgfSBlbHNlIGlmKExOR19OQU1FUy5pbmRleE9mKGROYW1lKT49MCl7XG4gICAgICAgIHF1ZXJ5ICs9IHRoaXMuZGFwUmFuZ2VRdWVyeShsbmdJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeSArPSB0aGlzLmRhcFJhbmdlUXVlcnkoYWRkaXRpb25hbEluZGljZXNbZE5hbWVdfHwwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICBkYXBSYW5nZVF1ZXJ5KGZyb206bnVtYmVyLHRvPzpudW1iZXIsc3RlcD86bnVtYmVyKTpzdHJpbmd7XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcbiAgICBpZih0bz09PXVuZGVmaW5lZCl7XG4gICAgICB0byA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiAnWycrZnJvbSsnOicrc3RlcCsnOicrdG8rJ10nO1xuICB9XG5cbiAgaW5kZXhJbkRpbWVuc2lvbihjOm51bWJlcixkaW06QXJyYXk8bnVtYmVyPix0cmltPzpudW1iZXIpOm51bWJlcntcbiAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgIHZhciBtYXhJbmRleCA9IGRpbS5sZW5ndGgtMTtcblxuICAgIGlmKHRyaW0pe1xuICAgICAgbWF4SW5kZXgtPXRyaW07XG4gICAgfVxuXG4gICAgY29uc3QgcmV2ID0gZGltWzBdID4gZGltW2RpbS5sZW5ndGgtMV07XG4gICAgaWYocmV2KXtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXg7XG4gICAgICBtYXhJbmRleCA9IDA7XG4gICAgfVxuICAgIHZhciBjdXJyZW50SW5kZXg7XG5cbiAgICB3aGlsZSgobWluSW5kZXg8PW1heEluZGV4KXx8KHJldiYmKG1heEluZGV4PD1taW5JbmRleCkpKXtcbiAgICAgIGlmKGM8PWRpbVttaW5JbmRleF0pe1xuICAgICAgICByZXR1cm4gbWluSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGlmKGM+PWRpbVttYXhJbmRleF0pe1xuICAgICAgICByZXR1cm4gbWF4SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRJbmRleCA9IE1hdGguZmxvb3IoKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMik7XG5cbiAgICAgIHZhciBkMSA9IE1hdGguYWJzKGRpbVtjdXJyZW50SW5kZXhdLWMpO1xuICAgICAgdmFyIGQyID0gTWF0aC5hYnMoZGltW2N1cnJlbnRJbmRleCsxXS1jKTtcblxuICAgICAgaWYocmV2KXtcbiAgICAgICAgaWYgKGQyIDw9IGQxKSB7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGQyIDw9IGQxKSB7XG4gICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICB9O1xuXG59XG4iXX0=